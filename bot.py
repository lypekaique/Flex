import discord
from discord import app_commands
from discord.ext import commands, tasks
import os
from dotenv import load_dotenv
from database import Database
from riot_api import RiotAPI
from datetime import datetime
from typing import Dict
import asyncio

# Carrega vari√°veis de ambiente
load_dotenv()

# Configura√ß√µes
TOKEN = os.getenv('DISCORD_TOKEN')
RIOT_API_KEY = os.getenv('RIOT_API_KEY')
DEFAULT_REGION = os.getenv('DEFAULT_REGION', 'br1')

# Inicializa bot e banco de dados
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)
db = Database()
riot_api = RiotAPI(RIOT_API_KEY)

@bot.event
async def on_ready():
    print(f'Bot {bot.user} est√° online!')
    print(f'ID: {bot.user.id}')
    print('------')
    
    # Sincroniza comandos slash
    try:
        synced = await bot.tree.sync()
        print(f'{len(synced)} comandos sincronizados')
    except Exception as e:
        print(f'Erro ao sincronizar comandos: {e}')
    
    # Inicia verifica√ß√£o de partidas
    check_new_matches.start()

@bot.tree.command(name="logar", description="Vincule sua conta do League of Legends (use formato: Nome#TAG)")
@app_commands.describe(
    riot_id="Seu Riot ID no formato Nome#TAG (ex: Faker#KR1)",
    regiao="Regi√£o do servidor (ex: br1, na1, euw1)"
)
async def logar(interaction: discord.Interaction, riot_id: str, regiao: str = DEFAULT_REGION):
    """Comando para vincular conta do LOL usando Riot ID (nome#tag)"""
    await interaction.response.defer(ephemeral=True)
    
    # Valida formato do Riot ID
    if '#' not in riot_id:
        await interaction.followup.send(
            "‚ùå Formato inv√°lido! Use o formato: **Nome#TAG**\n"
            "Exemplo: `Faker#KR1` ou `SeuNick#BR1`",
            ephemeral=True
        )
        return
    
    game_name, tag_line = riot_id.split('#', 1)
    
    # Normaliza regi√£o
    regiao = regiao.lower()
    if regiao not in RiotAPI.REGIONS:
        regioes_disponiveis = ', '.join(RiotAPI.REGIONS.keys())
        await interaction.followup.send(
            f"‚ùå Regi√£o inv√°lida! Regi√µes dispon√≠veis: {regioes_disponiveis}",
            ephemeral=True
        )
        return
    
    # Busca conta na API da Riot (Riot ID)
    account = await riot_api.get_account_by_riot_id(game_name, tag_line, regiao)
    
    if not account:
        await interaction.followup.send(
            f"‚ùå Conta '{riot_id}' n√£o encontrada.\n"
            f"Verifique se o nome e tag est√£o corretos!",
            ephemeral=True
        )
        return
    
    # Busca dados do summoner pelo PUUID
    summoner = await riot_api.get_summoner_by_puuid(account['puuid'], regiao)
    
    if not summoner:
        await interaction.followup.send(
            f"‚ùå Erro ao buscar dados do invocador na regi√£o {regiao.upper()}.",
            ephemeral=True
        )
        return
    
    # Adiciona conta ao banco de dados
    discord_id = str(interaction.user.id)
    success, message = db.add_lol_account(
        discord_id=discord_id,
        summoner_name=f"{game_name}#{tag_line}",
        summoner_id=summoner['id'],
        puuid=account['puuid'],
        account_id=summoner['accountId'],
        region=regiao
    )
    
    if success:
        # Cria embed bonito
        embed = discord.Embed(
            title="‚úÖ Conta Vinculada!",
            description=f"Conta **{game_name}#{tag_line}** vinculada com sucesso!",
            color=discord.Color.green()
        )
        embed.add_field(name="üåç Regi√£o", value=regiao.upper(), inline=True)
        embed.add_field(name="‚≠ê N√≠vel", value=summoner['summonerLevel'], inline=True)
        
        # Mostra quantas contas o usu√°rio tem
        accounts = db.get_user_accounts(discord_id)
        embed.add_field(
            name="üìä Contas Vinculadas", 
            value=f"{len(accounts)}/3", 
            inline=True
        )
        
        embed.set_footer(text="O bot come√ßar√° a monitorar suas partidas de Flex automaticamente!")
        await interaction.followup.send(embed=embed, ephemeral=True)
    else:
        await interaction.followup.send(f"‚ùå {message}", ephemeral=True)

@bot.tree.command(name="contas", description="Veja suas contas vinculadas do League of Legends")
async def contas(interaction: discord.Interaction):
    """Lista todas as contas vinculadas do usu√°rio"""
    await interaction.response.defer(ephemeral=True)
    
    discord_id = str(interaction.user.id)
    accounts = db.get_user_accounts(discord_id)
    
    if not accounts:
        await interaction.followup.send(
            "‚ùå Voc√™ n√£o tem nenhuma conta vinculada. Use `/logar` para vincular uma conta!",
            ephemeral=True
        )
        return
    
    # Cria embed com as contas
    embed = discord.Embed(
        title="üìã Suas Contas Vinculadas",
        description=f"Total: {len(accounts)}/3 contas",
        color=discord.Color.blue()
    )
    
    for i, account in enumerate(accounts, 1):
        embed.add_field(
            name=f"{i}. {account['summoner_name']}",
            value=f"üåç Regi√£o: {account['region'].upper()}\nüìÖ Vinculada em: {account['created_at'][:10]}",
            inline=False
        )
    
    await interaction.followup.send(embed=embed, ephemeral=True)

@bot.tree.command(name="media", description="Veja a m√©dia do seu carry score no m√™s")
@app_commands.describe(
    conta="N√∫mero da conta (1, 2 ou 3). Deixe vazio para ver todas"
)
async def media(interaction: discord.Interaction, conta: int = None):
    """Calcula a m√©dia de carry score do m√™s atual"""
    await interaction.response.defer()
    
    discord_id = str(interaction.user.id)
    accounts = db.get_user_accounts(discord_id)
    
    if not accounts:
        await interaction.followup.send(
            "‚ùå Voc√™ n√£o tem nenhuma conta vinculada. Use `/logar` para vincular uma conta!"
        )
        return
    
    # Se especificou uma conta, valida
    if conta is not None:
        if conta < 1 or conta > len(accounts):
            await interaction.followup.send(
                f"‚ùå Conta inv√°lida! Voc√™ tem {len(accounts)} conta(s) vinculada(s)."
            )
            return
        accounts = [accounts[conta - 1]]
    
    # Pega m√™s e ano atual
    now = datetime.now()
    month = now.month
    year = now.year
    
    # Cria embed para resultados
    embed = discord.Embed(
        title=f"üìä Estat√≠sticas de {now.strftime('%B/%Y')}",
        color=discord.Color.gold()
    )
    
    for account in accounts:
        matches = db.get_monthly_matches(account['id'], year, month)
        
        if not matches:
            embed.add_field(
                name=f"‚ö†Ô∏è {account['summoner_name']}",
                value="Nenhuma partida de Flex registrada este m√™s.",
                inline=False
            )
            continue
        
        # Calcula estat√≠sticas
        total_matches = len(matches)
        avg_carry = sum(m['carry_score'] for m in matches) / total_matches
        wins = sum(1 for m in matches if m['win'])
        win_rate = (wins / total_matches) * 100
        
        avg_kills = sum(m['kills'] for m in matches) / total_matches
        avg_deaths = sum(m['deaths'] for m in matches) / total_matches
        avg_assists = sum(m['assists'] for m in matches) / total_matches
        avg_kda_calc = (avg_kills + avg_assists) / max(avg_deaths, 1)
        avg_kp = sum(m['kill_participation'] for m in matches) / total_matches
        
        # Estat√≠sticas por role
        role_count = {}
        for m in matches:
            role = m['role']
            role_count[role] = role_count.get(role, 0) + 1
        most_played_role = max(role_count, key=role_count.get) if role_count else "Unknown"
        
        # Determina emoji baseado no carry score
        if avg_carry >= 70:
            emoji = "üèÜ"
            rank = "S+ Carry"
        elif avg_carry >= 60:
            emoji = "‚≠ê"
            rank = "S Carry"
        elif avg_carry >= 50:
            emoji = "üíé"
            rank = "A Carry"
        elif avg_carry >= 40:
            emoji = "ü•à"
            rank = "B Normal"
        else:
            emoji = "üìâ"
            rank = "C Weight"
        
        # Emoji por role
        role_emojis = {
            'Top': '‚öîÔ∏è',
            'Jungle': 'üå≥',
            'Mid': '‚ú®',
            'ADC': 'üèπ',
            'Support': 'üõ°Ô∏è'
        }
        role_emoji = role_emojis.get(most_played_role, '‚ùì')
        
        # Adiciona campo ao embed
        stats_text = f"""
{emoji} **{rank}**
üìà Carry Score M√©dio: **{int(avg_carry)}/100**
üéÆ Partidas: **{total_matches}** ‚Ä¢ ‚úÖ WR: **{win_rate:.1f}%**
‚öîÔ∏è KDA: **{avg_kda_calc:.2f}** ({avg_kills:.1f}/{avg_deaths:.1f}/{avg_assists:.1f})
üéØ Kill Participation: **{avg_kp:.1f}%**
{role_emoji} Role Mais Jogada: **{most_played_role}** ({role_count[most_played_role]}x)
        """
        
        embed.add_field(
            name=f"üéØ {account['summoner_name']} ({account['region'].upper()})",
            value=stats_text.strip(),
            inline=False
        )
    
    embed.set_footer(text="Apenas partidas de Ranked Flex s√£o contabilizadas")
    await interaction.followup.send(embed=embed)

@bot.tree.command(name="historico", description="Veja o hist√≥rico detalhado de partidas")
@app_commands.describe(
    conta="N√∫mero da conta (1, 2 ou 3)",
    quantidade="Quantidade de partidas para mostrar (padr√£o: 5)"
)
async def historico(interaction: discord.Interaction, conta: int = 1, quantidade: int = 5):
    """Mostra hist√≥rico detalhado de partidas"""
    await interaction.response.defer()
    
    discord_id = str(interaction.user.id)
    accounts = db.get_user_accounts(discord_id)
    
    if not accounts:
        await interaction.followup.send(
            "‚ùå Voc√™ n√£o tem nenhuma conta vinculada. Use `/logar` para vincular uma conta!"
        )
        return
    
    if conta < 1 or conta > len(accounts):
        await interaction.followup.send(
            f"‚ùå Conta inv√°lida! Voc√™ tem {len(accounts)} conta(s) vinculada(s)."
        )
        return
    
    account = accounts[conta - 1]
    now = datetime.now()
    matches = db.get_monthly_matches(account['id'], now.year, now.month)
    
    if not matches:
        await interaction.followup.send(
            f"‚ùå Nenhuma partida encontrada para **{account['summoner_name']}** este m√™s."
        )
        return
    
    # Limita quantidade
    matches = matches[:min(quantidade, 10)]
    
    embed = discord.Embed(
        title=f"üìú Hist√≥rico - {account['summoner_name']}",
        description=f"√öltimas {len(matches)} partidas de Ranked Flex",
        color=discord.Color.purple()
    )
    
    for i, match in enumerate(matches, 1):
        result = "‚úÖ Vit√≥ria" if match['win'] else "‚ùå Derrota"
        kda_ratio = f"{match['kills']}/{match['deaths']}/{match['assists']}"
        
        # Emoji do carry score
        if match['carry_score'] >= 70:
            carry_emoji = "üèÜ"
        elif match['carry_score'] >= 50:
            carry_emoji = "‚≠ê"
        elif match['carry_score'] >= 40:
            carry_emoji = "üíé"
        else:
            carry_emoji = "üìä"
        
        # Emoji por role
        role_emojis = {
            'Top': '‚öîÔ∏è',
            'Jungle': 'üå≥',
            'Mid': '‚ú®',
            'ADC': 'üèπ',
            'Support': 'üõ°Ô∏è'
        }
        role_emoji = role_emojis.get(match['role'], '‚ùì')
        
        match_info = f"""
{result} ‚Ä¢ **{match['champion_name']}** {role_emoji} {match['role']}
üìä KDA: {kda_ratio} ({match['kda']:.2f}) ‚Ä¢ KP: {match['kill_participation']:.0f}%
{carry_emoji} Carry Score: **{match['carry_score']}/100**
üó°Ô∏è Dano: {match['damage_dealt']:,} ‚Ä¢ üåæ CS: {match['cs']}
üìÖ {match['played_at'][:10]}
        """
        
        embed.add_field(
            name=f"#{i}",
            value=match_info.strip(),
            inline=False
        )
    
    await interaction.followup.send(embed=embed)

@bot.tree.command(name="configurar", description="[ADMIN] Configure os canais do bot")
@app_commands.describe(
    tipo="Tipo de configura√ß√£o: alertas (performance ruim) ou partidas (quando termina partida)",
    canal="Canal onde ser√£o enviadas as mensagens"
)
@app_commands.checks.has_permissions(administrator=True)
async def configurar(interaction: discord.Interaction, tipo: str, canal: discord.TextChannel):
    """Configura os canais do bot (apenas administradores)"""
    await interaction.response.defer(ephemeral=True)
    
    guild_id = str(interaction.guild_id)
    channel_id = str(canal.id)
    tipo = tipo.lower()
    
    if tipo not in ['alertas', 'partidas']:
        await interaction.followup.send(
            "‚ùå Tipo inv√°lido! Use: `alertas` ou `partidas`",
            ephemeral=True
        )
        return
    
    if tipo == 'alertas':
        success = db.set_notification_channel(guild_id, channel_id)
        if success:
            embed = discord.Embed(
                title="‚úÖ Canal de Alertas Configurado!",
                description=f"Alertas de performance ser√£o enviados em {canal.mention}",
                color=discord.Color.green()
            )
            embed.add_field(
                name="üì¢ O que ser√° notificado?",
                value=(
                    "‚Ä¢ Quando um jogador usar o **mesmo campe√£o 3x seguidas**\n"
                    "‚Ä¢ E tiver **carry score abaixo de 60** nas 3 partidas\n"
                    "‚Ä¢ Ser√° enviada uma notifica√ß√£o com sugest√µes"
                ),
                inline=False
            )
        else:
            await interaction.followup.send("‚ùå Erro ao configurar canal.", ephemeral=True)
            return
    
    else:  # partidas
        success = db.set_match_channel(guild_id, channel_id)
        if success:
            embed = discord.Embed(
                title="‚úÖ Canal de Partidas Configurado!",
                description=f"Partidas terminadas ser√£o enviadas em {canal.mention}",
                color=discord.Color.blue()
            )
            embed.add_field(
                name="üéÆ O que ser√° enviado?",
                value=(
                    "‚Ä¢ **Cada partida** de Flex que terminar\n"
                    "‚Ä¢ **Carry Score** da partida\n"
                    "‚Ä¢ **KDA, Role, Champion** e estat√≠sticas\n"
                    "‚Ä¢ **Resultado** (Vit√≥ria/Derrota)\n"
                    "‚Ä¢ Enviado automaticamente quando detectada"
                ),
                inline=False
            )
        else:
            await interaction.followup.send("‚ùå Erro ao configurar canal.", ephemeral=True)
            return
    
    # Mostra configura√ß√£o atual
    config = db.get_server_config(guild_id)
    config_text = "**Configura√ß√£o Atual:**\n"
    
    if config:
        if config['notification_channel_id']:
            config_text += f"üîî Alertas: <#{config['notification_channel_id']}>\n"
        else:
            config_text += "üîî Alertas: N√£o configurado\n"
        
        if config['match_channel_id']:
            config_text += f"üéÆ Partidas: <#{config['match_channel_id']}>\n"
        else:
            config_text += "üéÆ Partidas: N√£o configurado\n"
    
    embed.add_field(name="‚öôÔ∏è Status", value=config_text, inline=False)
    embed.set_footer(text="Use /configurar alertas #canal ou /configurar partidas #canal")
    await interaction.followup.send(embed=embed, ephemeral=True)

@bot.tree.command(name="tops_flex", description="Veja o ranking dos melhores jogadores do m√™s")
@app_commands.describe(
    quantidade="Quantidade de jogadores no ranking (padr√£o: 10)"
)
async def tops_flex(interaction: discord.Interaction, quantidade: int = 10):
    """Mostra o ranking dos melhores jogadores por carry score"""
    await interaction.response.defer()
    
    # Limita quantidade
    quantidade = max(5, min(quantidade, 25))
    
    # Busca ranking
    ranking = db.get_top_players_by_carry(limit=quantidade, min_games=5)
    
    if not ranking:
        await interaction.followup.send(
            "‚ùå Ainda n√£o h√° jogadores suficientes no ranking.\n"
            "**M√≠nimo:** 5 partidas de Flex no m√™s."
        )
        return
    
    # Cria embed
    now = datetime.now()
    embed = discord.Embed(
        title="üèÜ TOP FLEX PLAYERS - RANKING",
        description=f"**{now.strftime('%B/%Y')}** ‚Ä¢ M√≠nimo: 5 partidas",
        color=discord.Color.gold()
    )
    
    # Emojis de medalha
    medals = ["ü•á", "ü•à", "ü•â"]
    
    for i, player in enumerate(ranking, 1):
        # Emoji da posi√ß√£o
        if i <= 3:
            position_emoji = medals[i-1]
        else:
            position_emoji = f"**#{i}**"
        
        # Determina rank baseado no carry score
        avg_carry = player['avg_carry']
        if avg_carry >= 70:
            rank_emoji = "üèÜ S+"
        elif avg_carry >= 60:
            rank_emoji = "‚≠ê S"
        elif avg_carry >= 50:
            rank_emoji = "üíé A"
        elif avg_carry >= 40:
            rank_emoji = "ü•à B"
        else:
            rank_emoji = "üìä C"
        
        # Busca usu√°rio do Discord
        try:
            user = await bot.fetch_user(int(player['discord_id']))
            player_name = f"{user.mention}"
        except:
            player_name = player['summoner_name']
        
        player_info = f"""
{position_emoji} {player_name} ‚Ä¢ {rank_emoji}
üìà Carry: **{int(avg_carry)}/100** | üéÆ Jogos: **{player['total_games']}**
‚úÖ WR: **{player['win_rate']:.1f}%** | ‚öîÔ∏è KDA: **{player['avg_kda']:.2f}**
üéØ KP: **{player['avg_kp']:.1f}%**
        """
        
        embed.add_field(
            name=f"{player['summoner_name']} ({player['region'].upper()})",
            value=player_info.strip(),
            inline=False
        )
    
    embed.set_footer(text="Apenas Ranked Flex ‚Ä¢ Atualizado em tempo real")
    await interaction.followup.send(embed=embed)

async def send_match_notification(lol_account_id: int, stats: Dict):
    """Envia notifica√ß√£o quando uma partida termina"""
    try:
        # Busca informa√ß√µes da conta
        conn = db.get_connection()
        cursor = conn.cursor()
        cursor.execute('''
            SELECT discord_id, summoner_name FROM lol_accounts
            WHERE id = ?
        ''', (lol_account_id,))
        account_info = cursor.fetchone()
        conn.close()
        
        if not account_info:
            return
        
        discord_id, summoner_name = account_info
        
        # Busca todos os servidores onde est√° o bot
        for guild in bot.guilds:
            # Verifica se o usu√°rio est√° nesse servidor
            member = guild.get_member(int(discord_id))
            if not member:
                continue
            
            # Busca canal de partidas configurado
            channel_id = db.get_match_channel(str(guild.id))
            if not channel_id:
                continue
            
            # Busca o canal
            channel = guild.get_channel(int(channel_id))
            if not channel:
                continue
            
            # Determina cor baseada no resultado
            if stats['win']:
                color = discord.Color.green()
                result_emoji = "‚úÖ"
                result_text = "VIT√ìRIA"
            else:
                color = discord.Color.red()
                result_emoji = "‚ùå"
                result_text = "DERROTA"
            
            # Determina emoji e rank do carry score
            carry_score = stats['carry_score']
            if carry_score >= 70:
                rank_emoji = "üèÜ"
                rank_text = "S+ CARRY"
            elif carry_score >= 60:
                rank_emoji = "‚≠ê"
                rank_text = "S CARRY"
            elif carry_score >= 50:
                rank_emoji = "üíé"
                rank_text = "A"
            elif carry_score >= 40:
                rank_emoji = "ü•à"
                rank_text = "B"
            else:
                rank_emoji = "üìâ"
                rank_text = "C"
            
            # Emoji por role
            role_emojis = {
                'Top': '‚öîÔ∏è',
                'Jungle': 'üå≥',
                'Mid': '‚ú®',
                'ADC': 'üèπ',
                'Support': 'üõ°Ô∏è'
            }
            role_emoji = role_emojis.get(stats['role'], '‚ùì')
            
            # Cria embed
            embed = discord.Embed(
                title=f"{result_emoji} {result_text} - {stats['champion_name']}",
                description=f"{member.mention} terminou uma partida de Ranked Flex!",
                color=color
            )
            
            # Informa√ß√µes principais
            embed.add_field(
                name="üéÆ Partida",
                value=(
                    f"{role_emoji} **{stats['role']}** - {stats['champion_name']}\n"
                    f"‚öîÔ∏è KDA: **{stats['kills']}/{stats['deaths']}/{stats['assists']}** ({stats['kda']:.2f})\n"
                    f"üéØ Kill Part: **{stats['kill_participation']:.0f}%**"
                ),
                inline=True
            )
            
            # Carry Score (destaque)
            embed.add_field(
                name="üèÜ Performance",
                value=(
                    f"{rank_emoji} **{rank_text}**\n"
                    f"üìä Carry Score\n"
                    f"# **{carry_score}**/100"
                ),
                inline=True
            )
            
            # Estat√≠sticas adicionais
            game_duration_min = stats['game_duration'] // 60
            embed.add_field(
                name="üìä Estat√≠sticas",
                value=(
                    f"üó°Ô∏è Dano: **{stats['damage_dealt']:,}**\n"
                    f"üåæ CS: **{stats['cs']}**\n"
                    f"üëÅÔ∏è Vision: **{stats['vision_score']}**\n"
                    f"‚è±Ô∏è Dura√ß√£o: **{game_duration_min}min**"
                ),
                inline=True
            )
            
            embed.set_footer(text=f"{summoner_name} ‚Ä¢ {stats['played_at'][:10]}")
            embed.set_thumbnail(url=member.display_avatar.url)
            
            # Envia notifica√ß√£o
            try:
                await channel.send(embed=embed)
                print(f"üéÆ Partida enviada: {summoner_name} - {stats['champion_name']} (Score: {carry_score})")
            except Exception as e:
                print(f"Erro ao enviar partida: {e}")
    
    except Exception as e:
        print(f"Erro ao processar notifica√ß√£o de partida: {e}")

async def check_champion_performance(lol_account_id: int, champion_name: str):
    """Verifica se o jogador teve 3 performances ruins seguidas com o mesmo campe√£o"""
    try:
        # Busca as √∫ltimas 3 partidas com esse campe√£o
        matches = db.get_last_n_matches_with_champion(lol_account_id, champion_name, n=3)
        
        # Se n√£o tem 3 partidas ainda, n√£o faz nada
        if len(matches) < 3:
            return
        
        # Verifica se todas as 3 t√™m score abaixo de 60
        all_bad_scores = all(match['carry_score'] < 60 for match in matches)
        
        if not all_bad_scores:
            return
        
        # Busca informa√ß√µes da conta
        conn = db.get_connection()
        cursor = conn.cursor()
        cursor.execute('''
            SELECT discord_id, summoner_name FROM lol_accounts
            WHERE id = ?
        ''', (lol_account_id,))
        account_info = cursor.fetchone()
        conn.close()
        
        if not account_info:
            return
        
        discord_id, summoner_name = account_info
        
        # Busca todos os servidores onde est√° o bot
        for guild in bot.guilds:
            # Verifica se o usu√°rio est√° nesse servidor
            member = guild.get_member(int(discord_id))
            if not member:
                continue
            
            # Busca canal de notifica√ß√µes configurado para esse servidor
            channel_id = db.get_notification_channel(str(guild.id))
            if not channel_id:
                continue
            
            # Busca o canal
            channel = guild.get_channel(int(channel_id))
            if not channel:
                continue
            
            # Calcula m√©dia dos scores
            avg_score = sum(m['carry_score'] for m in matches) / 3
            
            # Cria embed de "vergonha"
            embed = discord.Embed(
                title="‚ö†Ô∏è ALERTA DE PERFORMANCE BAIXA",
                description=f"{member.mention} est√° com dificuldades em **{champion_name}**!",
                color=discord.Color.red()
            )
            
            embed.add_field(
                name="üìä Estat√≠sticas Recentes",
                value=(
                    f"üéÆ **3 √∫ltimas partidas** com {champion_name}\n"
                    f"üìâ Carry Score m√©dio: **{int(avg_score)}/100**\n"
                    f"‚ö†Ô∏è Todas abaixo de 60!"
                ),
                inline=False
            )
            
            # Adiciona detalhes das 3 partidas
            matches_text = ""
            for i, match in enumerate(matches, 1):
                result_emoji = "‚úÖ" if match['win'] else "‚ùå"
                matches_text += (
                    f"{result_emoji} **{match['carry_score']}** - "
                    f"{match['kills']}/{match['deaths']}/{match['assists']} "
                    f"({match['role']})\n"
                )
            
            embed.add_field(
                name="üéØ √öltimas 3 Partidas",
                value=matches_text.strip(),
                inline=False
            )
            
            embed.add_field(
                name="üí° Sugest√£o",
                value=(
                    "Considere:\n"
                    "‚Ä¢ Trocar de campe√£o temporariamente\n"
                    "‚Ä¢ Rever builds e runas\n"
                    "‚Ä¢ Assistir replays das partidas\n"
                    "‚Ä¢ Praticar em Normal antes de voltar ao Ranked"
                ),
                inline=False
            )
            
            embed.set_footer(text=f"Conta: {summoner_name}")
            
            # Envia notifica√ß√£o
            try:
                await channel.send(embed=embed)
                print(f"‚ö†Ô∏è Notifica√ß√£o enviada: {summoner_name} com {champion_name} ({avg_score:.2f})")
            except Exception as e:
                print(f"Erro ao enviar notifica√ß√£o: {e}")
    
    except Exception as e:
        print(f"Erro ao verificar performance: {e}")

@tasks.loop(minutes=5)
async def check_new_matches():
    """Task que verifica novas partidas a cada 5 minutos"""
    try:
        # Busca todas as contas vinculadas
        conn = db.get_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT id, puuid, region FROM lol_accounts')
        accounts = cursor.fetchall()
        conn.close()
        
        for account_id, puuid, region in accounts:
            # Busca √∫ltimas partidas
            match_ids = await riot_api.get_match_history(puuid, region, count=5)
            
            if not match_ids:
                continue
            
            # Verifica se s√£o partidas novas
            last_match = db.get_last_match_id(account_id)
            
            for match_id in match_ids:
                # Se j√° foi registrada, para
                if match_id == last_match:
                    break
                
                # Busca detalhes da partida
                match_data = await riot_api.get_match_details(match_id, region)
                
                if match_data:
                    # Extrai estat√≠sticas do jogador
                    stats = riot_api.extract_player_stats(match_data, puuid)
                    
                    if stats:
                        # Salva no banco de dados
                        db.add_match(account_id, stats)
                        print(f"Nova partida registrada: {match_id} (Score: {stats['carry_score']})")
                        
                        # Envia notifica√ß√£o de partida terminada
                        await send_match_notification(account_id, stats)
                        
                        # Verifica se jogou 3x o mesmo campe√£o com score baixo
                        await check_champion_performance(account_id, stats['champion_name'])
                
                # Delay para n√£o sobrecarregar a API
                await asyncio.sleep(1)
            
            await asyncio.sleep(2)
    
    except Exception as e:
        print(f"Erro ao verificar partidas: {e}")

@check_new_matches.before_loop
async def before_check_matches():
    """Espera o bot estar pronto antes de iniciar o loop"""
    await bot.wait_until_ready()

# Tratamento de erros
@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        await interaction.response.send_message(
            f"‚è∞ Aguarde {error.retry_after:.1f} segundos antes de usar este comando novamente.",
            ephemeral=True
        )
    else:
        await interaction.response.send_message(
            f"‚ùå Ocorreu um erro: {str(error)}",
            ephemeral=True
        )
        print(f"Erro no comando: {error}")

if __name__ == "__main__":
    if not TOKEN or not RIOT_API_KEY:
        print("‚ùå ERRO: Configure as vari√°veis DISCORD_TOKEN e RIOT_API_KEY no arquivo .env")
        print("Veja o arquivo .env.example para mais informa√ß√µes")
    else:
        bot.run(TOKEN)

